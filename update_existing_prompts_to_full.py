#!/usr/bin/env python3
"""
Update existing placeholder prompts with full prompts from hardcoded files.
This script matches existing prompts by doc_type and updates them with full content.
"""

import re
from pathlib import Path
import sys

# Prompt file locations and their corresponding database doc_types
PROMPT_MAPPING = {
    'engineering': {
        'path': 'services/prompts/engineering_prompt.py',
        'function': 'get_engineering_prompt',
        'doc_type': 'engineering',  # This matches existing prompt
        'db_doc_type': 'beam-schedule',  # For new prompts
    },
    'finance': {
        'path': 'services/prompts/finance_prompt.py',
        'function': 'get_finance_prompt',
        'doc_type': 'finance',  # This matches existing prompt
        'db_doc_type': 'vendor-invoice',  # For new prompts
    },
    'logistics': {
        'path': 'services/prompts/logistics_prompt.py',
        'function': 'get_logistics_prompt',
        'doc_type': 'logistics',  # This matches existing prompt
        'db_doc_type': 'fta-list',  # For new prompts
    },
    'transmittal': {
        'path': 'services/prompts/transmittal_prompt.py',
        'function': 'get_transmittal_prompt',
        'doc_type': 'transmittal',  # This matches existing prompt
        'db_doc_type': 'drawing-register',  # For new prompts
    }
}

def extract_prompt_from_function(file_path, function_name):
    """Extract the prompt text from a Python function that returns an f-string."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"[WARNING] File not found: {file_path}")
        return None
    
    # Find function definition
    func_pattern = rf'def {function_name}\(.*?\):'
    func_match = re.search(func_pattern, content, re.DOTALL)
    
    if not func_match:
        print(f"[WARNING] Function {function_name} not found in {file_path}")
        return None
    
    # Find return f""" after function definition
    remaining = content[func_match.end():]
    return_match = re.search(r'return\s+f"""', remaining, re.MULTILINE)
    
    if not return_match:
        print(f"[WARNING] return f\"\"\" not found after {function_name} in {file_path}")
        return None
    
    # Extract everything after f""" until the closing """
    prompt_start = return_match.end()
    prompt_content = remaining[prompt_start:]
    
    # Find the closing """ - look for """ that's on its own line (with possible indentation)
    # Match """ followed by optional whitespace and end of line
    closing_match = re.search(r'"""\s*$', prompt_content, re.MULTILINE)
    
    if not closing_match:
        print(f"[WARNING] Closing \"\"\" not found in {file_path}")
        return None
    
    prompt_text = prompt_content[:closing_match.start()].rstrip()
    return prompt_text

def generate_update_sql(prompt_type, config, prompt_text):
    """Generate SQL UPDATE statement for existing prompts."""
    if not prompt_text:
        return None
    
    # Generate a unique dollar-quote tag
    tag = f"{prompt_type.upper()}_PROMPT_{hash(prompt_text) % 100000}"
    
    sql = f"""-- ============================================================================
-- UPDATE {prompt_type.upper()} PROMPT WITH FULL CONTENT
-- Source: {config['path']} -> {config['function']}()
-- Prompt Length: {len(prompt_text):,} characters
-- ============================================================================

UPDATE prompt_templates
SET 
    prompt_text = ${tag}${prompt_text}${tag}$,
    updated_at = CURRENT_TIMESTAMP
WHERE doc_type = '{config['doc_type']}' 
  AND scope = 'document_type';

-- Verify the update
SELECT 
    name,
    doc_type,
    LENGTH(prompt_text) as new_length,
    is_active,
    updated_at
FROM prompt_templates
WHERE doc_type = '{config['doc_type']}' 
  AND scope = 'document_type';

"""
    return sql

def main():
    """Main function to generate UPDATE SQL for all prompts."""
    print("=" * 80)
    print("Generating SQL to UPDATE existing placeholder prompts with full content")
    print("=" * 80)
    print()
    
    base_dir = Path(__file__).parent
    all_sql = []
    
    # Header SQL
    header_sql = """-- ============================================================================
-- UPDATE EXISTING PROMPTS WITH FULL CONTENT
-- Generated by update_existing_prompts_to_full.py
-- This updates existing prompts (engineering_extraction_rules, etc.) with full prompts
-- ============================================================================

"""
    all_sql.append(header_sql)
    
    # Process each prompt
    for prompt_type, config in PROMPT_MAPPING.items():
        print(f"Extracting {prompt_type} prompt...")
        file_path = base_dir / config['path']
        
        prompt_text = extract_prompt_from_function(str(file_path), config['function'])
        
        if prompt_text:
            sql = generate_update_sql(prompt_type, config, prompt_text)
            if sql:
                all_sql.append(sql)
                print(f"  [OK] Extracted {len(prompt_text):,} characters")
            else:
                print(f"  [ERROR] Failed to generate SQL")
        else:
            print(f"  [ERROR] Failed to extract prompt")
        print()
    
    # Output
    full_sql = '\n'.join(all_sql)
    
    # Save to file
    output_file = base_dir / 'update_prompts_to_full.sql'
    output_file.write_text(full_sql, encoding='utf-8')
    
    print("=" * 80)
    print(f"[SUCCESS] SQL saved to: {output_file}")
    print("=" * 80)
    print()
    print("Next steps:")
    print("  1. Run this SQL file in your PostgreSQL database:")
    print("     railway run psql < update_prompts_to_full.sql")
    print("  2. Or use Railway Dashboard -> Database -> Query tab")
    print("  3. This will update existing prompts with full content")
    print("  4. Check admin panel - lengths should now be:")
    print("     - Engineering: ~48,848 chars")
    print("     - Finance: ~10,279 chars")
    print("     - Logistics: ~7,191 chars")
    print("     - Transmittal: ~3,480 chars")
    print()

if __name__ == '__main__':
    main()
